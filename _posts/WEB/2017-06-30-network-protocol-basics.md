---
title: 网络基础之网络协议
layout: post
---

* TOC
{:toc}

<br><br>

　　操作系统(Operating System，简称OS)：是管理和控制计算机硬件与软件资源的计算机程序，
是直接运行在“裸机”上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。  

`注：计算机(硬件)－>os－>应用软件`

### 网络通信原理

`互联网的本质就是一系列的网络协议`  
　　一台硬设有了操作系统，然后装上软件你就可以正常使用了，然而你也只能自己使用每个人都拥有一台自己的机器，彼此孤立。  
　　如何能大家一起玩耍？就需要接入到 `internet` 。  
　　然而internet为何物？其实两台计算机之间通信与两个人打电话之间通信的原理是一样的（中国有很多地区，不同的地区有不同的方言，
为了全中国人都可以听懂，大家统一讲普通话）。普通话属于中国国内人与人之间通信的标准，那如果是两个国家的人交流呢？
问题是，你不可能要求一个人／计算机掌握全世界的语言／标准，于是有了世界统一的通信标准：英语  
　　结论：英语成为世界上所有人通信的统一标准，如果把计算机看成分布于世界各地的人，那么连接两台计算机之间的 internet 实际上就是一系列统一的标准，
这些标准称之为互联网协议，互联网的本质就是一系列的协议，总称为‘互联网协议’（Internet Protocol Suite)。  
`互联网协议的功能：定义计算机如何接入 internet，以及接入 internet 的计算机通信的标准` 。  

### osi七层协议

互联网协议按照功能不同分为 `osi七层` 或 `tcp/ip五层` 或 `tcp/ip四层`  

![]({{site.baseurl}}/images/images/1036857-20161008145544426-736439132.png)  
<br>
每层运行常见物理设备  

![]({{site.baseurl}}/images/images/1036857-20161008144925254-1398507493.png)  

### tcp/ip五层模型

　　我们将应用层，表示层，会话层并作应用层，从tcp／ip五层协议的角度来阐述每层的由来与功能，搞清楚了每层的主要协议就理解了整个互联网通信的原理。  
　　首先，用户感知到的只是最上面一层应用层，自上而下每层都依赖于下一层，所以我们从最下一层开始切入，比较好理解每层都运行特定的协议，越往上越靠近用户，越往下越靠近硬件  

#### 物理层

物理层由来：上面提到，孤立的计算机之间要想一起玩，就必须接入internet，言外之意就是计算机之间必须完成组网  
物理层功能：主要是基于电器特性发送高低电压(电信号)，高电压对应数字1，低电压对应数字0  

![]({{site.baseurl}}/images/images/1036857-20161008154500754-704720294.png)  

#### 数据链路层

数据链路层由来：单纯的电信号0和1没有任何意义，必须规定电信号多少位一组，每组什么意思  
数据链路层的功能：定义了电信号的分组方式  
`以太网协议`  
　　早期的时候各个公司都有自己的分组方式，后来形成了统一的标准，即以太网协议 `ethernet`  
ethernet规定
- 一组电信号构成一个数据包，叫做‘帧’。
- 每一数据帧分成：`报头head` 和 `数据data` 两部分  

|:--:|:--:|
|　　head　　|　　　data　　　　　|

head包含：(固定18个字节)  
- 发送者／源地址，6个字节
- 接收者／目标地址，6个字节
- 数据类型，6个字节  

data包含：(最短46字节，最长1500字节)  
- 数据包的具体内容  

head长度＋data长度＝最短64字节，最长1518字节，超过最大限制就分片发送  

`mac地址`  
　　head 中包含的源和目标地址由来：ethernet 规定接入 internet 的设备都必须具备网卡，发送端和接收端的地址便是指网卡的地址，即mac地址  
　　mac地址：每块网卡出厂时都被烧制上一个世界唯一的 mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）  

`广播`  
　　有了 mac地址，同一网络内的两台主机就可以通信了（一台主机通过 `arp协议` 获取另外一台主机的 mac地址）ethernet 采用最原始的方式，广播的方式进行通信，即计算机通信基本靠吼  

<br>

![]({{site.baseurl}}/images/images/1036857-20161008171118317-164674895.png)  

#### 网络层

网络层由来：有了ethernet、mac地址、广播的发送方式，世界上的计算机就可以彼此通信了，问题是世界范围的互联网是由一个个彼此隔离的小的局域网组成的，那么如果所有的通信都采用以太网的广播方式，那么一台机器发送的包全世界都会收到，
这就不仅仅是效率低的问题了，这会是一种灾难  
网络层功能：引入一套新的地址用来区分不同的广播域／子网，这套地址即网络地址  
<br>

![]({{site.baseurl}}/images/images/1036857-20161008172732957-102296982.png)  

　　上图结论：必须找出一种方法来区分哪些计算机属于同一广播域，哪些不是，如果是就采用广播的方式发送，如果不是，
就采用路由的方式（向不同广播域／子网分发数据包），mac地址是无法区分的，它只跟厂商有关  

`IP协议`

　　规定网络地址的协议叫 ip协议，它定义的地址称之为 ip地址，广泛采用的 v4版本即 ipv4，它规定网络地址由32位2进制表示范围0.0.0.0-255.255.255.255  
　　一个ip地址通常写成四段十进制数，例：172.16.10.1  

`ip地址分成两部分`  
　　网络部分：标识子网  
　　主机部分：标识主机  

注意：单纯的 ip地址段只是标识了 ip地址的种类，从网络部分或主机部分都无法辨识一个 ip 所处的子网  
例：172.16.10.1与172.16.10.2并不能确定二者处于同一子网  

`子网掩码`  

　　所谓 ”子网掩码” ，就是表示子网络特征的一个参数。它在形式上等同于 IP地址，也是一个32位二进制数字。
它的网络部分全部为1，主机部分全部为0。  
　　比如，IP地址172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。  
　　知道 ”子网掩码” ，我们就能判断，任意两个IP地址是否处在同一个子网络。
方法是将两个 IP地址与子网掩码分别进行 `AND运算`（两个数位都为1，运算结果为1，否则为0），
然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。  
<br>
比如，已知 IP地址172.16.10.1和172.16.10.2的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？  
两者与子网掩码分别进行AND运算  
172.16.10.1：10101100.00010000.00001010.000000001  
255255.255.255.0:11111111.11111111.11111111.00000000  
AND运算得网络地址结果：10101100.00010000.00001010.000000001->172.16.10.0  
172.16.10.2：10101100.00010000.00001010.000000010  
255255.255.255.0:11111111.11111111.11111111.00000000  
AND运算得网络地址结果：10101100.00010000.00001010.000000001->172.16.10.0  
结果都是172.16.10.0，因此它们在同一个子网络。  

`总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配 IP地址，另一个是确定哪些地址在同一个子网络`  
<br>

`ip数据包`  

　　ip数据包也分为 head 和 data 部分，无须为 ip包 定义单独的栏位，直接放入以太网包的data部分  
　　head：长度为20到60字节  
　　data：最长为65,515字节  

而以太网数据包的 ”数据” 部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。  

|:--:|:--:|:--:|
|　　以太网头　　|　　  ip 头　　　|　　　ip数据　　　|

`ARP协议`  

　　arp协议由来：计算机通信基本靠吼，即广播的方式，所有上层的包到最后都要封装上以太网头，然后通过以太网协议发送，
在谈及以太网协议时候，我门了解到：通信是基于 mac 的广播方式实现，计算机在发包时，获取自身的 mac 是容易的，如何获取目标主机的 mac ，就需要通过 arp协议  
　　arp协议功能：广播的方式发送数据包，获取目标主机的 mac地址  

协议工作方式：每台主机 ip 都是已知的  

例如：主机172.16.10.10/24访问172.16.10.11/24（IP后面表示子网掩码的位数）  

一：首先通过 ip地址和子网掩码区分出自己所处的子网  

|:--:|:--:|:--:|
|场景|数据包地址|
|同一子网|目标主机mac，目标主机ip|
|不同子网|网关mac，目标主机ip|

二：分析172.16.10.10/24与172.16.10.11/24处于同一网络(如果不是同一网络，那么下表中目标ip为172.16.10.11,通过 arp获取的是网关的mac)  

|:--:|:--:|:--:|
||源mac|目标mac|源ip|目标ip|数据部分|
|发送端主机|发送端mac|FF:FF:FF:FF:FF:FF|172.16.10.10/24|172.16.10.11/24|数据|

三：这个包会以广播的方式在发送端所处的自网内传输，所有主机接收后拆开包，发现目标ip为自己的，就响应，返回自己的mac  

#### 传输层

传输层的由来：网络层的ip帮我们区分子网，以太网层的mac帮我们找到主机，然后大家使用的都是应用程序，
你的电脑上可能同时开启qq，暴风影音，等多个应用程序，
那么我们通过 ip 和 mac 找到了一台特定的主机，如何标识这台主机上的应用程序，答案就是端口，端口即应用程序与网卡关联的编号。  
传输层功能：建立端口到端口的通信  
补充：端口范围0-65535，0-1023为系统占用端口  

`tcp协议`  

　　可靠传输，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过 IP数据包的长度，
以确保单个TCP数据包不必再分割。  

|:--:|:--:|:--:|
|　　以太网头　　|　　ip头　　|　　tcp头　　|　　　数据　　　　|

`udp协议`  

　　不可靠传输，”报头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。  

|:--:|:--:|:--:|
|　　以太网头　　|　　ip头　　|　　udp头　　|　　　数据　　　　|

tcp报文  
<br>
![]({{site.baseurl}}/images/images/1036857-20161008185553973-1895926477.png)  
<br>
注：syn=1 表示发起请求建立连接，ack+1 表示确认响应，fin 表示断开连接

`tcp三次握手和四次挥手`  
<br>
![]({{site.baseurl}}/images/images/1036857-20161008185648160-191189690.png)  
<br>

#### 应用层

应用层由来：用户使用的都是应用程序，均工作于应用层，互联网是开发的，大家都可以开发自己的应用程序，数据多种多样，
必须规定好数据的组织形式  
应用层功能：规定应用程序的数据格式。  
　　例：TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。
那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了 ”应用层”。  

<br>
![]({{site.baseurl}}/images/images/1036857-20161008190023098-992049015.png)  
<br>

### socket

　　我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用 PID 来唯一标示一个进程，
但 PID 只在本地唯一，网络中的两个进程 PID 冲突几率很大，这时候我们需要另辟它径了，我们知道 IP 层的 ip地址可以唯一标示主机，
而 TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。  
　　能够唯一标示网络中的进程后，它们就可以利用 socket 进行通信了，什么是 socket 呢？我们经常把 socket 翻译为套接字，socket 是在应用层和传输层之间的一个抽象层，它把 TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。  

<br>
![]({{site.baseurl}}/images/images/1036857-20161013091647484-1707663286.png)  
<br>

　　socket 起源于 UNIX ，在 Unix 一切皆文件哲学的思想下，socket 是一种 "打开—读/写—关闭" 模式的实现，
服务器和客户端各自维护一个 "文件"，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。